#include <CLI/App.hpp>
#include <CLI/Config.hpp>
#include <CLI/Formatter.hpp>
#include <filesystem>
#include <fmt/os.h>
#include <occ/core/kabsch.h>
#include <occ/core/log.h>
#include <occ/core/units.h>
#include <occ/crystal/crystal.h>
#include <occ/dft/dft.h>
#include <occ/interaction/disp.h>
#include <occ/interaction/pairinteraction.h>
#include <occ/interaction/polarization.h>
#include <occ/io/cifparser.h>
#include <occ/io/fchkreader.h>
#include <occ/io/fchkwriter.h>
#include <occ/main/pair_energy.h>
#include <occ/qm/hf.h>
#include <occ/qm/scf.h>
#include <occ/qm/wavefunction.h>

namespace fs = std::filesystem;
using occ::core::Dimer;
using occ::core::Element;
using occ::core::Molecule;
using occ::crystal::Crystal;
using occ::crystal::SymmetryOperation;
using occ::interaction::CEEnergyComponents;
using occ::interaction::CEModelInteraction;
using occ::main::LatticeConvergenceSettings;
using occ::qm::HartreeFock;
using occ::qm::SpinorbitalKind;
using occ::qm::Wavefunction;
using occ::scf::SCF;
using occ::units::AU_TO_KCAL_PER_MOL;
using occ::units::AU_TO_KJ_PER_MOL;
using occ::units::BOHR_TO_ANGSTROM;
using occ::util::all_close;

std::string dimer_symop(const occ::core::Dimer &dimer, const Crystal &crystal) {
    const auto &a = dimer.a();
    const auto &b = dimer.b();
    if (a.asymmetric_molecule_idx() != b.asymmetric_molecule_idx())
        return "-";

    int sa_int = a.asymmetric_unit_symop()(0);
    int sb_int = b.asymmetric_unit_symop()(0);

    SymmetryOperation symop_a(sa_int);
    SymmetryOperation symop_b(sb_int);

    auto symop_ab = symop_b * symop_a.inverted();
    occ::Vec3 c_a =
        symop_ab(crystal.to_fractional(a.positions())).rowwise().mean();
    occ::Vec3 v_ab = crystal.to_fractional(b.centroid()) - c_a;

    symop_ab = symop_ab.translated(v_ab);
    return symop_ab.to_string();
}

Crystal read_crystal(const std::string &filename) {
    occ::io::CifParser parser;
    return parser.parse_crystal(filename).value();
}

std::vector<Wavefunction>
calculate_wavefunctions(const std::string &basename,
                        const std::vector<Molecule> &molecules,
                        const std::string &model) {
    auto parameterized_model = occ::interaction::ce_model_from_string(model);
    std::vector<Wavefunction> wfns;
    size_t index = 0;
    for (const auto &m : molecules) {
        fs::path fchk_path(
            fmt::format("{}_{}_{}.fchk", basename, index, model));
        fmt::print("Molecule ({})\n{:3s} {:^10s} {:^10s} {:^10s}\n", index,
                   "sym", "x", "y", "z");
        for (const auto &atom : m.atoms()) {
            fmt::print("{:^3s} {:10.6f} {:10.6f} {:10.6f}\n",
                       Element(atom.atomic_number).symbol(), atom.x, atom.y,
                       atom.z);
        }
        if (fs::exists(fchk_path)) {
            using occ::io::FchkReader;
            FchkReader fchk(fchk_path.string());
            auto wfn = Wavefunction(fchk);
            wfns.push_back(wfn);
        } else {
            auto basis =
                occ::qm::AOBasis::load(m.atoms(), parameterized_model.basis);
            basis.set_pure(false);
            fmt::print("Loaded basis set, {} shells, {} basis functions\n",
                       basis.size(), basis.nbf());
            std::string fchk_title = fmt::format(
                "{} {}/{} generated by occ", fchk_path.stem().string(),
                parameterized_model.method, parameterized_model.basis);
            if (parameterized_model.method == "hf") {
                HartreeFock hf(basis);
                SCF<HartreeFock> scf(hf, SpinorbitalKind::Restricted);
                scf.set_charge_multiplicity(0, 1);
                double e = scf.compute_scf_energy();
                auto wfn = scf.wavefunction();
                occ::io::FchkWriter fchk(fchk_path.string());
                fchk.set_title(fchk_title);
                fchk.set_method(parameterized_model.method);
                fchk.set_basis_name(parameterized_model.basis);
                wfn.save(fchk);
                fchk.write();
                wfns.push_back(wfn);
            } else {
                occ::dft::DFT rks(parameterized_model.method, basis);
                SCF<occ::dft::DFT> scf(rks, SpinorbitalKind::Restricted);

                scf.set_charge_multiplicity(0, 1);
                scf.convergence_settings.incremental_fock_threshold = 0.0;
                double e = scf.compute_scf_energy();
                auto wfn = scf.wavefunction();
                occ::io::FchkWriter fchk(fchk_path.string());
                fchk.set_title(fchk_title);
                fchk.set_method(parameterized_model.method);
                fchk.set_basis_name(parameterized_model.basis);
                wfn.save(fchk);
                fchk.write();
                wfns.push_back(wfn);
            }
        }

        index++;
    }
    return wfns;
}

void compute_monomer_energies(std::vector<Wavefunction> &wfns,
                              const std::string &model_name) {
    size_t complete = 0;
    auto model = occ::interaction::ce_model_from_string(model_name);
    CEModelInteraction interaction(model);
    fmt::print("Model: {}\n", model_name);

    for (auto &wfn : wfns) {
        fmt::print("Calculating monomer energies {}/{}\n", complete,
                   wfns.size());
        std::cout << std::flush;
        interaction.compute_monomer_energies(wfn);
        complete++;
    }
    fmt::print("Finished calculating {} unique monomer energies\n", complete);
}

void calculate_lattice_energy(const std::string &cif_filename,
                              const std::string &model_name,
                              const LatticeConvergenceSettings settings) {
    std::string filename = cif_filename;
    std::string basename = fs::path(filename).stem().string();
    Crystal c = read_crystal(filename);
    fmt::print("Energy model: {}\n", model_name);
    fmt::print("Loaded crystal from {}\n", filename);
    auto molecules = c.symmetry_unique_molecules();
    fmt::print("Symmetry unique molecules in {}: {}\n", filename,
               molecules.size());

    std::vector<Wavefunction> wfns;
    fmt::print("Calculating symmetry unique dimers\n");
    occ::crystal::CrystalDimers crystal_dimers;
    std::vector<CEEnergyComponents> energies;
    occ::main::LatticeEnergyResult lattice_energy_result;
    if (model_name == "xtb") {
        lattice_energy_result =
            converged_xtb_lattice_energies(c, basename, settings);
    } else {
        wfns = calculate_wavefunctions(basename, molecules, model_name);
        compute_monomer_energies(wfns, model_name);
        lattice_energy_result = occ::main::converged_lattice_energies(
            c, wfns, wfns, basename, settings);
    }

    const auto &dimers = lattice_energy_result.dimers.unique_dimers;
    if (dimers.size() < 1) {
        fmt::print("No dimers found using neighbour radius {:.3f}\n",
                   settings.max_radius);
        exit(0);
    }

    const std::string row_fmt_string = "{:>7.3f} {:>7.3f} {:>20s} {: 8.3f} {: "
                                       "8.3f} {: 8.3f} {: 8.3f} {: 8.3f} {: "
                                       "8.3f}\n";
    size_t mol_idx{0};
    double etot{0.0}, elat{0.0};
    for (const auto &n : lattice_energy_result.dimers.molecule_neighbors) {

        fmt::print("Neighbors for molecule {}\n", mol_idx);

        fmt::print("{:>7s} {:>7s} {:>20s} {:>8s} {:>8s} {:>8s} {:>8s} {:>8s} "
                   "{:>8s}\n",
                   "Rn", "Rc", "Symop", "E_coul", "E_ex", "E_rep", "E_pol",
                   "E_disp", "E_tot");
        fmt::print("==================================================="
                   "================================\n");
        CEEnergyComponents molecule_total;

        size_t j = 0;
        for (const auto &[dimer, idx] : n) {
            auto s_ab = dimer_symop(dimer, c);
            double rn = dimer.nearest_distance();
            double rc = dimer.center_of_mass_distance();
            const auto &e = lattice_energy_result.energy_components[idx];
            if (!e.is_computed) {
                j++;
                continue;
            }
            double ecoul = e.coulomb_kjmol(), e_ex = e.exchange_kjmol(),
                   e_rep = e.repulsion_kjmol(), epol = e.polarization_kjmol(),
                   edisp = e.dispersion_kjmol(), etot_mol = e.total_kjmol();
            molecule_total = molecule_total + e;
            fmt::print(row_fmt_string, rn, rc, s_ab, ecoul, e_ex, e_rep, epol,
                       edisp, etot_mol);
            j++;
        }
        fmt::print("Molecule {} total: {:.3f} kJ/mol ({} pairs)\n", mol_idx,
                   molecule_total.total_kjmol(), j);
        etot += molecule_total.total_kjmol();
        mol_idx++;
    }
    fmt::print("Final energy: {:.3f} kJ/mol\n", etot * 0.5);
    fmt::print("Lattice energy: {:.3f} kJ/mol\n",
               lattice_energy_result.lattice_energy);
}

int main(int argc, char *argv[]) {
    CLI::App app("occ-elat - Crystal lattice energy");
    std::string cif_filename{""}, verbosity{"warn"}, model_name{"ce-b3lyp"};
    int threads{1};
    double radius{30.0}, radius_increment{3.8};
    bool use_wolf_sum{false};

    CLI::Option *input_option =
        app.add_option("input", cif_filename, "input CIF");
    input_option->required();
    app.add_option("-t,--threads", threads, "number of threads");
    app.add_option("-r,--radius", radius,
                   "maximum radius (Angstroms) for neighbours");
    app.add_option("--radius-increment", radius_increment,
                   "step size (Angstroms) direct space summation");
    app.add_option("-m,--model", model_name, "CE model");
    app.add_option("-v,--verbosity", verbosity, "logging verbosity");
    app.add_flag("-w,--wolf", use_wolf_sum,
                 "accelerate convergence using Wolf sum");

    CLI11_PARSE(app, argc, argv);
    occ::log::setup_logging(verbosity);

    occ::parallel::set_num_threads(std::max(1, threads));

    fmt::print("Parallelized over {} threads & {} Eigen threads\n",
               occ::parallel::get_num_threads(), Eigen::nbThreads());

    const std::string error_format =
        "Exception:\n    {}\nTerminating program.\n";
    try {
        LatticeConvergenceSettings settings;
        settings.max_radius = radius;
        settings.model_name = model_name;
        settings.wolf_sum = use_wolf_sum;

        calculate_lattice_energy(cif_filename, model_name, settings);

        occ::timing::print_timings();

    } catch (const char *ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::string &ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::exception &ex) {
        fmt::print(error_format, ex.what());
        return 1;
    } catch (...) {
        fmt::print("Exception:\n- Unknown...\n");
        return 1;
    }

    return 0;
}
