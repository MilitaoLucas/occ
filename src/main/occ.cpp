#include <cxxopts.hpp>
#include <filesystem>
#include <fmt/core.h>
#include <fmt/ostream.h>
#include <iostream>
#include <occ/core/logger.h>
#include <occ/core/timings.h>
#include <occ/io/fchkwriter.h>
#include <occ/io/xyz.h>
#include <occ/io/gaussian_input_file.h>
#include <occ/io/qcschema.h>
#include <occ/io/occ_input.h>
#include <occ/qm/partitioning.h>
#include <spdlog/cfg/env.h>
#include <occ/main/single_point.h>
#include <occ/main/version.h>
#include <occ/core/units.h>
#include <occ/core/util.h>
#include <occ/core/parallel.h>
#include <xc.h>

namespace fs = std::filesystem;
using occ::io::OccInput;
using occ::qm::Wavefunction;
using occ::qm::SpinorbitalKind;

void read_input_file(OccInput &config) {
    occ::timing::stop(occ::timing::category::io);
    std::string ext = fs::path(config.filename).extension();
    if (ext == ".gjf" || ext == ".com") {
        occ::io::GaussianInputFile g(config.filename);
        g.update_occ_input(config);
    }
    else if (ext == ".json") {
        occ::io::QCSchemaReader qcs(config.filename);
        qcs.update_occ_input(config);
    }
    else if (ext == ".xyz") {
        occ::io::XyzFileReader xyz(config.filename);
        xyz.update_occ_input(config);
    }
}

void write_output_files(const OccInput &config, Wavefunction &wfn) {
    fs::path fchk_path = config.filename;
    if(!config.solvent.solvent_name.empty()) {
        fchk_path.replace_extension(".solvated.fchk");
    }
    else {
        fchk_path.replace_extension(".fchk");
    }
    occ::io::FchkWriter fchk(fchk_path.string());
    fchk.set_title(fmt::format("{} {}/{} generated by occ",
                               fchk_path.stem(), config.method.name,
                               config.basis.name));
    fchk.set_method(config.method.name);
    fchk.set_basis_name(config.basis.name);
    wfn.save(fchk);
    fchk.write();
    fmt::print("wavefunction stored in {}\n", fchk_path);
}

int main(int argc, char *argv[]) {
    occ::timing::start(occ::timing::category::global);
    occ::timing::start(occ::timing::category::io);
    cxxopts::Options options("occ", "A program for quantum chemistry");
    options.positional_help("[input_file] [method] [basis]")
        .show_positional_help();

    options.add_options()("h,help", "print help")(
        "i,input", "input file", cxxopts::value<std::string>())(
        "b,basis", "basis set name",
        cxxopts::value<std::string>()->default_value("3-21G"))(
        "d,df-basis", "basis set name", cxxopts::value<std::string>())(
        "t,threads", "number of threads",
        cxxopts::value<int>()->default_value("1"))(
        "m,method", "QM method",
        cxxopts::value<std::string>()->default_value("rhf"))(
        "c,charge", "system net charge",
        cxxopts::value<int>()->default_value("0"))(
        "n,multiplicity", "system multiplicity",
        cxxopts::value<int>()->default_value("1"))(
        "u,unrestricted", "use unrestricted DFT",
        cxxopts::value<bool>()->default_value("false"))(
        "v,verbosity", "logging verbosity",
        cxxopts::value<std::string>()->default_value("WARN"))(
        "spherical", "use spherical basis functions",
        cxxopts::value<bool>()->default_value("false"))(
        "s,solvent", "use SMD solvation model with solvent",
        cxxopts::value<std::string>())("f,solvent-file",
                                       "write solvation surface to file",
                                       cxxopts::value<std::string>());

    options.parse_positional({"input", "method", "basis"});

    auto result = options.parse(argc, argv);

    if (result.count("help")) {
        fmt::print("{}\n", options.help());
        exit(0);
    }

    auto level = occ::log::level::warn;
    if (result.count("verbosity")) {
        std::string level_lower =
            occ::util::to_lower_copy(result["verbosity"].as<std::string>());
        if (level_lower == "debug")
            level = occ::log::level::debug;
        else if (level_lower == "info")
            level = occ::log::level::info;
        else if (level_lower == "error")
            level = occ::log::level::err;
    }
    occ::log::set_level(level);
    spdlog::set_level(level);
    occ::main::print_header();
    occ::timing::stop(occ::timing::category::io);

    const std::string error_format =
        "exception:\n    {}\nterminating program.\n";

    if (result.count("input") == 0) {
        occ::log::error("must provide an input file!");
        exit(1);
    }

    try {
        libint2::Shell::do_enforce_unit_normalization(true);
        libint2::initialize();
        occ::timing::start(occ::timing::category::io);

        OccInput config;
        config.filename = result["input"].as<std::string>();
        // read input file first so we can override with command line settings
        read_input_file(config);

        using occ::parallel::nthreads;
        nthreads = result["threads"].as<int>();

        fmt::print("\nparallelization: {} threads, {} eigen threads\n",
                   nthreads, Eigen::nbThreads());

        if(result.count("basis"))
            config.basis.name = result["basis"].as<std::string>();
        if(result.count("multiplicity"))
            config.electronic.multiplicity = result["multiplicity"].as<int>();
        if(result.count("method"))
            config.method.name = result["method"].as<std::string>();
        if(result.count("charge"))
            config.electronic.charge = result["charge"].as<int>();
        if(result.count("spherical"))
            config.basis.spherical = result["spherical"].as<bool>();

        if (result.count("df-basis"))
            config.basis.df_name =
                result["df-basis"].as<std::string>();
        if (config.electronic.multiplicity != 1 || result.count("unrestricted") ||
            config.method.name == "uhf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::Unrestricted;
            fmt::print("spinorbital kind: unrestricted");
        } else if (config.method.name == "ghf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::General;
            fmt::print("spinorbital kind: general\n");
        } else {
            fmt::print("spinorbital kind: restricted\n");
        }


        occ::timing::stop(occ::timing::category::io);
        Wavefunction wfn = occ::main::single_point_calculation(config);
        write_output_files(config, wfn);


        if (result.count("solvent")) {
            config.solvent.solvent_name = result["solvent"].as<std::string>();
            if (result.count("solvent-file"))
                config.solvent.output_surface_filename =
                    result["solvent-file"].as<std::string>();
            Wavefunction wfn2 = occ::main::single_point_calculation(config, wfn);
            double esolv = wfn2.energy.total - wfn.energy.total;

            fmt::print("estimated \u0394G(solv) {:20.12f} ({:.3f} kJ/mol, "
                       "{:.3f} kcal/mol)\n",
                       esolv, esolv * occ::units::AU_TO_KJ_PER_MOL,
                       esolv * occ::units::AU_TO_KCAL_PER_MOL);
            write_output_files(config, wfn2);
        }

    } catch (const char *ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::string &ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::exception &ex) {
        fmt::print(error_format, ex.what());
        return 1;
    } catch (...) {
        fmt::print("Exception:\n- Unknown...\n");
        return 1;
    }
    occ::timing::stop(occ::timing::global);
    occ::timing::print_timings();
    return 0;
}
