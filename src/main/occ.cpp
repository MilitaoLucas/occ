#include <CLI/App.hpp>
#include <CLI/Config.hpp>
#include <CLI/Formatter.hpp>
#include <filesystem>
#include <fmt/core.h>
#include <fmt/ostream.h>
#include <iostream>
#include <occ/core/log.h>
#include <occ/core/parallel.h>
#include <occ/core/timings.h>
#include <occ/core/units.h>
#include <occ/core/util.h>
#include <occ/io/fchkwriter.h>
#include <occ/io/gaussian_input_file.h>
#include <occ/io/occ_input.h>
#include <occ/io/qcschema.h>
#include <occ/io/xyz.h>
#include <occ/main/pair_energy.h>
#include <occ/main/properties.h>
#include <occ/main/single_point.h>
#include <occ/main/version.h>
#include <spdlog/cfg/env.h>
#include <xc.h>

namespace fs = std::filesystem;
using occ::io::OccInput;
using occ::qm::SpinorbitalKind;
using occ::qm::Wavefunction;

void read_input_file(const std::string &filename, OccInput &config) {
    occ::timing::stop(occ::timing::category::io);
    auto path = fs::path(filename);
    std::string ext = path.extension().string();
    occ::log::debug("Attempting to read input from {}, file extension = {}",
                    filename, ext);
    if (!fs::exists(path))
        throw std::runtime_error("Input file does not exist.");
    if (ext == ".gjf" || ext == ".com") {
        occ::log::debug("Detected Gaussian input file");
        occ::io::GaussianInputFile g(filename);
        g.update_occ_input(config);
    } else if (ext == ".json") {
        occ::log::debug("Detected JSON input");
        occ::io::QCSchemaReader qcs(filename);
        qcs.update_occ_input(config);
    } else if (ext == ".xyz") {
        occ::log::debug("Detected xyz input");
        occ::io::XyzFileReader xyz(filename);
        xyz.update_occ_input(config);
    } else {
        throw std::runtime_error("unknown file type");
    }
}

void write_output_files(const OccInput &config, Wavefunction &wfn) {
    fs::path fchk_path = config.filename;
    if (!config.solvent.solvent_name.empty()) {
        fchk_path.replace_extension(".solvated.fchk");
    } else {
        fchk_path.replace_extension(".fchk");
    }
    occ::io::FchkWriter fchk(fchk_path.string());
    fchk.set_title(fmt::format("{} {}/{} generated by occ",
                               fchk_path.stem().string(), config.method.name,
                               config.basis.name));
    fchk.set_method(config.method.name);
    fchk.set_basis_name(config.basis.name);
    wfn.save(fchk);
    fchk.write();
    occ::log::info("wavefunction stored in {}", fchk_path.string());
}

void setup_logging(const std::string &verbosity) {
    auto level = occ::log::level::info;
    std::string level_lower = occ::util::to_lower_copy(verbosity);
    if (level_lower == "debug")
        level = occ::log::level::trace;
    else if (level_lower == "normal")
        level = occ::log::level::info;
    else if (level_lower == "verbose")
        level = occ::log::level::debug;
    else if (level_lower == "minimal")
        level = occ::log::level::warn;
    else if (level_lower == "silent")
        level = occ::log::level::critical;
    occ::log::set_level(level);
    spdlog::set_level(level);
    // store the last 32 debug messages in a buffer
    spdlog::enable_backtrace(32);
    spdlog::set_pattern("%v");
}

int main(int argc, char *argv[]) {
    occ::timing::start(occ::timing::category::global);
    occ::timing::start(occ::timing::category::io);
    CLI::App app("occ - A program for quantum chemistry");
    std::string input_file{""}, method{"rhf"}, basis_set{"3-21G"},
        verbosity{"warn"};
    std::optional<std::string> df_basis{}, solvent{},
        solvent_surface_filename{};
    int threads{1}, charge{0}, multiplicity{1};
    bool unrestricted{false}, spherical{false};

    CLI::Option *input_option =
        app.add_option("input", input_file, "input file");
    input_option->required();
    app.add_option("method", method, "method");
    app.add_option("basis", basis_set, "basis set");
    app.add_option("-d,--df-basis", df_basis, "basis set");
    app.add_option("-t,--threads", threads, "number of threads");
    app.add_option("-c,--charge", charge, "system net charge");
    app.add_option("--multiplicity", charge, "system multiplicity");
    app.add_flag("-u,--unrestricted", unrestricted, "use unrestricted SCF");
    app.add_option("-v,--verbosity", verbosity, "logging verbosity");
    app.add_flag("--spherical", spherical, "use spherical basis sets");
    app.add_flag("-s,--solvent", solvent, "use spherical basis sets");
    app.add_flag("-f,--solvent-file", solvent_surface_filename,
                 "file to write solvent surface");

    CLI11_PARSE(app, argc, argv);
    setup_logging(verbosity);

    occ::main::print_header();
    occ::timing::stop(occ::timing::category::io);

    const std::string error_format =
        "exception:\n    {}\nterminating program.\n";

    try {
        occ::timing::start(occ::timing::category::io);

        OccInput config;
        config.name = input_file;
        // read input file first so we can override with command line settings
        read_input_file(input_file, config);
        if (config.filename.empty()) {
            config.filename = config.name;
        }

        occ::parallel::set_num_threads(std::max(1, config.driver.threads));
        occ::parallel::set_num_threads(threads);

#ifdef _OPENMP
        std::string thread_type = "OpenMP";
#else
        std::string thread_type = "std";
#endif
        occ::log::info("\nParallelization: {} {} threads, {} eigen threads",
                       occ::parallel::get_num_threads(), thread_type,
                       Eigen::nbThreads());

        config.basis.name = basis_set;
        config.electronic.multiplicity = multiplicity;
        config.method.name = method;
        config.electronic.charge = charge;
        config.basis.spherical = spherical;
        if (df_basis)
            config.basis.df_name = *df_basis;
        if (config.electronic.multiplicity != 1 || unrestricted ||
            config.method.name == "uhf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::Unrestricted;
            occ::log::info("Spinorbital kind: Unrestricted");
        } else if (config.method.name == "ghf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::General;
            occ::log::info("Spinorbital kind: General");
        } else {
            occ::log::info("Spinorbital kind: Restricted");
        }
        occ::timing::stop(occ::timing::category::io);

        if (config.driver.driver == "energy") {
            occ::log::debug("Using energy driver");
            Wavefunction wfn = occ::main::single_point_calculation(config);
            write_output_files(config, wfn);
            occ::main::calculate_properties(config, wfn);

            if (solvent) {
                config.solvent.solvent_name = *solvent;

                if (solvent_surface_filename)
                    config.solvent.output_surface_filename =
                        *solvent_surface_filename;
                Wavefunction wfn2 =
                    occ::main::single_point_calculation(config, wfn);
                double esolv = wfn2.energy.total - wfn.energy.total;

                occ::log::info("{:â€”<72s}", "Solvation free energy (SMD)  ");
                occ::log::info("\u0394G(solv)    = {:20.12f} Hartree", esolv);
                occ::log::info("            = {:20.12f} kJ/mol",
                               esolv * occ::units::AU_TO_KJ_PER_MOL);
                occ::log::info("            = {:20.12f} kcal/mol",
                               esolv * occ::units::AU_TO_KCAL_PER_MOL);
                write_output_files(config, wfn2);
            }
        } else if (config.driver.driver == "pair_energy") {
            occ::log::info("Using pair energy driver\n");
            occ::main::PairEnergy pair_energy(config);
            pair_energy.compute();
        } else {
            throw std::runtime_error(
                fmt::format("Unknown driver: {}", config.driver.driver));
            return 1;
        }

    } catch (const char *ex) {
        occ::log::error(error_format, ex);
        spdlog::dump_backtrace();
        return 1;
    } catch (std::string &ex) {
        occ::log::error(error_format, ex);
        spdlog::dump_backtrace();
        return 1;
    } catch (std::exception &ex) {
        occ::log::error(error_format, ex.what());
        spdlog::dump_backtrace();
        return 1;
    } catch (...) {
        occ::log::error("Exception:\n- Unknown...\n");
        spdlog::dump_backtrace();
        return 1;
    }
    occ::timing::stop(occ::timing::global);
    occ::timing::print_timings();
    occ::log::info("A job well done\n");
    return 0;
}
