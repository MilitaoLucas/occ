#include <CLI/App.hpp>
#include <CLI/Config.hpp>
#include <CLI/Formatter.hpp>
#include <filesystem>
#include <fmt/core.h>
#include <fmt/ostream.h>
#include <iostream>
#include <occ/core/log.h>
#include <occ/core/parallel.h>
#include <occ/core/timings.h>
#include <occ/core/units.h>
#include <occ/core/util.h>
#include <occ/io/cifparser.h>
#include <occ/io/crystal_json.h>
#include <occ/io/fchkwriter.h>
#include <occ/io/gaussian_input_file.h>
#include <occ/io/occ_input.h>
#include <occ/io/qcschema.h>
#include <occ/io/xyz.h>
#include <occ/main/cli_validators.h>
#include <occ/main/pair_energy.h>
#include <occ/main/properties.h>
#include <occ/main/single_point.h>
#include <occ/main/version.h>
#include <spdlog/cfg/env.h>
#include <xc.h>

namespace fs = std::filesystem;
using occ::io::OccInput;
using occ::qm::SpinorbitalKind;
using occ::qm::Wavefunction;

void read_input_file(const std::string &filename, OccInput &config) {
    occ::timing::stop(occ::timing::category::io);
    auto path = fs::path(filename);
    std::string ext = path.extension().string();
    occ::log::debug("Attempting to read input from {}, file extension = {}",
                    filename, ext);
    if (!fs::exists(path))
        throw std::runtime_error("Input file does not exist.");
    if (ext == ".gjf" || ext == ".com") {
        occ::log::debug("Detected Gaussian input file");
        occ::io::GaussianInputFile g(filename);
        g.update_occ_input(config);
    } else if (ext == ".json") {
        occ::log::debug("Detected JSON input");
        occ::io::QCSchemaReader qcs(filename);
        qcs.update_occ_input(config);
    } else if (ext == ".xyz") {
        occ::log::debug("Detected xyz input");
        occ::io::XyzFileReader xyz(filename);
        xyz.update_occ_input(config);
    } else if (ext == ".cif") {
        occ::log::debug("Detected CIF input");
        occ::io::CifParser cif;
        auto crystal = cif.parse_crystal(filename);
        if (!crystal)
            throw std::runtime_error(fmt::format("Could not parse crystal: {}",
                                                 cif.failure_description()));
        config.crystal.asymmetric_unit = (*crystal).asymmetric_unit();
        config.crystal.unit_cell = (*crystal).unit_cell();
        config.crystal.space_group = (*crystal).space_group();
        config.driver.driver = "crystal";
    } else {
        throw std::runtime_error("unknown file type");
    }
}

void write_output_files(const OccInput &config, Wavefunction &wfn) {
    fs::path fchk_path = config.filename;
    if (!config.solvent.solvent_name.empty()) {
        fchk_path.replace_extension(".solvated.fchk");
    } else {
        fchk_path.replace_extension(".fchk");
    }
    occ::io::FchkWriter fchk(fchk_path.string());
    fchk.set_title(fmt::format("{} {}/{} generated by occ",
                               fchk_path.stem().string(), config.method.name,
                               config.basis.name));
    fchk.set_method(config.method.name);
    fchk.set_basis_name(config.basis.name);
    wfn.save(fchk);
    fchk.write();
    occ::log::info("wavefunction stored in {}", fchk_path.string());
}

int main(int argc, char *argv[]) {
    occ::timing::start(occ::timing::category::global);
    occ::timing::start(occ::timing::category::io);

    OccInput config;

    CLI::App app("occ - A program for quantum chemistry");
    app.allow_config_extras(CLI::config_extras_mode::error);
    std::string input_file{""}, verbosity{"normal"};
    bool unrestricted{false};

    CLI::Option *input_option =
        app.add_option("input,--geometry-filename,--geometry_filename",
                       input_file, "input file");
    input_option->check(CLI::ExistingFile);
    input_option->required();
    app.set_config("--config", "occ_input.toml",
                   "Read configuration from an ini or TOML file", false);
    app.add_option("method_name,--method", config.method.name, "method name");
    app.add_option("basis_name,--basis", config.basis.name, "basis set name");
    app.add_option("-t,--threads", config.runtime.threads, "number of threads");
    // electronic
    app.add_option("-c,--charge", config.electronic.charge,
                   "system net charge");
    auto *multiplicity_option =
        app.add_option("--multiplicity", config.electronic.multiplicity,
                       "system multiplicity");
    multiplicity_option->check(occ::main::validator::Multiplicity);

    app.add_flag("-u,--unrestricted", unrestricted, "use unrestricted SCF");

    // dft grid
    app.add_option("--dft-grid-max-angular,--dft_grid_max_angular",
                   config.method.dft_grid.max_angular_points,
                   "maximum angular grid points for DFT integration");
    app.add_option("--dft-grid-min-angular,--dft_grid_min_angular",
                   config.method.dft_grid.min_angular_points,
                   "minimum angular grid points for DFT integration");
    app.add_option("--dft-grid-radial-precision,--dft_grid_radial_precision",
                   config.method.dft_grid.radial_precision,
                   "radial precision for DFT integration");
    app.add_option(
        "--dft-grid-reduce-light-elements,--dft_grid_reduce_light_elements",
        config.method.dft_grid.reduced_first_row_element_grid,
        "radial precision for DFT integration");

    // basis set
    app.add_option("-d,--df-basis,--density_fitting_basis",
                   config.basis.df_name, "basis set");
    app.add_flag("--spherical", config.basis.spherical,
                 "use spherical basis sets");
    // Solvation
    app.add_flag("-s,--solvent,--solvent_name", config.solvent.solvent_name,
                 "use spherical basis sets");
    app.add_flag("-f,--solvent-file,--solvent_file",
                 config.solvent.output_surface_filename,
                 "file to write solvent surface");
    // XDM
    app.add_flag("--xdm", config.dispersion.evaluate_correction,
                 "use XDM dispersion correction");
    app.add_flag("--xdm-a1,--xdm_a1", config.dispersion.xdm_a1,
                 "a1 parameter for XDM");
    app.add_flag("--xdm-a2,--xdm_a2", config.dispersion.xdm_a2,
                 "a2 parameter for XDM");

    // logging verbosity
    app.add_option("-v,--verbosity", verbosity,
                   "logging verbosity {silent,minimal,normal,verbose,debug}");

    CLI11_PARSE(app, argc, argv);
    occ::log::setup_logging(verbosity);

    occ::main::print_header();
    occ::timing::stop(occ::timing::category::io);

    const std::string error_format =
        "exception:\n    {}\nterminating program.\n";

    try {
        occ::timing::start(occ::timing::category::io);

        config.name = input_file;
        // read input file first so we can override with command line settings
        read_input_file(input_file, config);
        if (config.filename.empty()) {
            config.filename = config.name;
        }

        occ::parallel::set_num_threads(std::max(1, config.runtime.threads));

#ifdef _OPENMP
        std::string thread_type = "OpenMP";
#else
        std::string thread_type = "std";
#endif
        occ::log::info("\nParallelization: {} {} threads, {} eigen threads",
                       occ::parallel::get_num_threads(), thread_type,
                       Eigen::nbThreads());

        if (config.method.name[0] == 'u')
            unrestricted = true;

        if ((config.electronic.multiplicity != 1) || unrestricted ||
            config.method.name == "uhf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::Unrestricted;
            if (config.method.name == "rhf") {
                config.method.name = "uhf";
            } else {
                if (config.method.name[0] != 'u') {
                    config.method.name = "u" + config.method.name;
                }
            }
            occ::log::info("Spinorbital kind: Unrestricted");
        } else if (config.method.name == "ghf") {
            config.electronic.spinorbital_kind = SpinorbitalKind::General;
            occ::log::info("Spinorbital kind: General");
        } else {
            occ::log::info("Spinorbital kind: Restricted");
        }
        occ::timing::stop(occ::timing::category::io);

        if (config.driver.driver == "energy") {
            occ::log::debug("Using energy driver");
            // store solvent name so we can do an unsolvated calculation first
            std::string stored_solvent_name = config.solvent.solvent_name;
            config.solvent.solvent_name = "";

            Wavefunction wfn = occ::main::single_point_calculation(config);
            write_output_files(config, wfn);
            occ::main::calculate_dispersion(config, wfn);
            occ::main::calculate_properties(config, wfn);

            config.solvent.solvent_name = stored_solvent_name;

            if (!config.solvent.solvent_name.empty()) {
                Wavefunction wfn2 =
                    occ::main::single_point_calculation(config, wfn);
                double esolv = wfn2.energy.total - wfn.energy.total;

                occ::log::info("{:-<72s}", "Solvation free energy (SMD)  ");
                occ::log::info("dG(solv)    = {:20.12f} Hartree", esolv);
                occ::log::info("            = {:20.12f} kJ/mol",
                               esolv * occ::units::AU_TO_KJ_PER_MOL);
                occ::log::info("            = {:20.12f} kcal/mol",
                               esolv * occ::units::AU_TO_KCAL_PER_MOL);
                write_output_files(config, wfn2);
            }
        } else if (config.driver.driver == "pair_energy") {
            occ::log::info("Using pair energy driver\n");
            occ::main::PairEnergy pair_energy(config);
            pair_energy.compute();
        } else if (config.driver.driver == "crystal") {
            occ::log::info("Using crystal driver\n");
            occ::crystal::Crystal crystal(config.crystal.asymmetric_unit,
                                          config.crystal.space_group,
                                          config.crystal.unit_cell);
            nlohmann::json json_data = crystal;
            auto path = fs::path(config.filename);
            path.replace_extension(".cxc.json");
            occ::log::info("Writing crystal data to {}\n", path.string());
            std::ofstream of(path.string());
            of << std::setw(2) << json_data << std::endl;

        } else {
            throw std::runtime_error(
                fmt::format("Unknown driver: {}", config.driver.driver));
            return 1;
        }

    } catch (const char *ex) {
        occ::log::error(error_format, ex);
        spdlog::dump_backtrace();
        return 1;
    } catch (std::string &ex) {
        occ::log::error(error_format, ex);
        spdlog::dump_backtrace();
        return 1;
    } catch (std::exception &ex) {
        occ::log::error(error_format, ex.what());
        spdlog::dump_backtrace();
        return 1;
    } catch (...) {
        occ::log::error("Exception:\n- Unknown...\n");
        spdlog::dump_backtrace();
        return 1;
    }
    occ::timing::stop(occ::timing::global);
    occ::timing::print_timings();
    occ::log::info("A job well done\n");
    return 0;
}
