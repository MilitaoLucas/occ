#include <occ/crystal/crystal.h>
#include <occ/io/cifparser.h>
#include <occ/3rdparty/argparse.hpp>
#include <occ/qm/wavefunction.h>
#include <occ/core/logger.h>
#include <occ/qm/hf.h>
#include <occ/dft/dft.h>
#include <occ/qm/scf.h>
#include <occ/io/fchkwriter.h>
#include <occ/io/fchkreader.h>
#include <occ/interaction/pairinteraction.h>
#include <occ/interaction/disp.h>
#include <occ/interaction/polarization.h>
#include <occ/solvent/solvation_correction.h>
#include <filesystem>
#include <occ/core/units.h>
#include <fmt/os.h>

namespace fs = std::filesystem;
using occ::crystal::Crystal;
using occ::crystal::SymmetryOperation;
using occ::chem::Molecule;
using occ::chem::Dimer;
using occ::qm::Wavefunction;
using occ::qm::SpinorbitalKind;
using occ::qm::BasisSet;
using occ::scf::SCF;
using occ::units::BOHR_TO_ANGSTROM;
using occ::units::AU_TO_KJ_PER_MOL;
using occ::units::AU_TO_KCAL_PER_MOL;
using occ::interaction::CEModelInteraction;
using occ::chem::Element;
using occ::util::all_close;
using occ::hf::HartreeFock;
using occ::solvent::COSMO;

struct SolvatedSurfaceProperties
{
    occ::Mat3N coulomb_pos;
    occ::Mat3N cds_pos;
    occ::Vec e_coulomb;
    occ::Vec e_cds;
};

std::string dimer_symop(const occ::chem::Dimer &dimer, const Crystal &crystal)
{
    const auto& a = dimer.a();
    const auto& b = dimer.b();
    if(a.asymmetric_molecule_idx() != b.asymmetric_molecule_idx()) return "-";

    int sa_int = a.asymmetric_unit_symop()(0);
    int sb_int = b.asymmetric_unit_symop()(0);

    SymmetryOperation symop_a(sa_int);
    SymmetryOperation symop_b(sb_int);

    auto symop_ab = symop_b * symop_a.inverted();
    occ::Vec3 c_a = symop_ab(crystal.to_fractional(a.positions())).rowwise().mean();
    occ::Vec3 v_ab = crystal.to_fractional(b.centroid()) - c_a;

    symop_ab = symop_ab.translated(v_ab);
    return symop_ab.to_string();
}

Crystal read_crystal(const std::string &filename)
{
    occ::io::CifParser parser;
    return parser.parse_crystal(filename).value();
}

std::vector<Wavefunction> calculate_wavefunctions(const std::string &basename, const std::vector<Molecule> &molecules)
{
    const std::string method = "b3lyp";
    const std::string basis_name = "6-31G**";
    std::vector<Wavefunction> wfns;
    size_t index = 0;
    for(const auto& m: molecules)
    {
        fs::path fchk_path(fmt::format("{}_{}.fchk", basename, index));
        auto dmat = fmt::output_file(fmt::format("{}_{}.txt", basename, index));
        fmt::print("Molecule ({})\n{:3s} {:^10s} {:^10s} {:^10s}\n", index, "sym", "x", "y", "z");
        for (const auto &atom : m.atoms()) {
            fmt::print("{:^3s} {:10.6f} {:10.6f} {:10.6f}\n", Element(atom.atomic_number).symbol(),
                       atom.x, atom.y, atom.z);
        }
        if(fs::exists(fchk_path)) {
            using occ::io::FchkReader;
            FchkReader fchk(fchk_path.string());
            auto wfn = Wavefunction(fchk);
            dmat.print("{}", wfn.D);
            wfns.push_back(wfn);
        }
        else {
            BasisSet basis(basis_name, m.atoms());
            basis.set_pure(false);
            fmt::print("Loaded basis set, {} shells, {} basis functions\n", basis.size(), libint2::nbf(basis));
//            HartreeFock hf(m.atoms(), basis);
//            SCF<HartreeFock, SpinorbitalKind::Restricted> scf(hf);
            occ::dft::DFT rks(method, basis, m.atoms(), SpinorbitalKind::Restricted);
            SCF<occ::dft::DFT, SpinorbitalKind::Restricted> scf(rks);

            scf.set_charge_multiplicity(0, 1);
            scf.start_incremental_F_threshold = 0.0;
            double e = scf.compute_scf_energy();
            auto wfn = scf.wavefunction();
            dmat.print("{}", wfn.D);
            occ::io::FchkWriter fchk(fchk_path.string());
            fchk.set_title(fmt::format("{} {}/{} generated by occ-ng", fchk_path.stem(), method, basis_name));
            fchk.set_method(method);
            fchk.set_basis_name(basis_name);
            wfn.save(fchk);
            fchk.write();
            wfns.push_back(wfn);
        }

        index++;
    }
    return wfns;

}

std::vector<SolvatedSurfaceProperties> calculate_solvated_surfaces(
        const std::string &basename, const std::vector<Wavefunction> &wfns,
        const std::string& solvent_name)
{
    std::vector<SolvatedSurfaceProperties> result;
    using occ::solvent::SolvationCorrectedProcedure;
    using occ::dft::DFT;
    const std::string method = "b3lyp";
    const std::string basis_name = "6-31G**";
    std::vector<Wavefunction> solvated_wfns;
    size_t index = 0;
    for(const auto& wfn: wfns)
    {
        SolvatedSurfaceProperties props;
        BasisSet basis(basis_name, wfn.atoms);
        basis.set_pure(false);
        fmt::print("Loaded basis set, {} shells, {} basis functions\n", basis.size(), libint2::nbf(basis));
        occ::dft::DFT ks(method, basis, wfn.atoms, SpinorbitalKind::Restricted);
        SolvationCorrectedProcedure<DFT> proc_solv(ks, solvent_name);
        SCF<SolvationCorrectedProcedure<DFT>, SpinorbitalKind::Restricted> scf(proc_solv);
        scf.start_incremental_F_threshold = 0.0;
        scf.set_charge_multiplicity(0, 1);
        double e = scf.compute_scf_energy();
        props.coulomb_pos = proc_solv.surface_positions_coulomb();
        props.cds_pos = proc_solv.surface_positions_cds();
        props.e_cds = proc_solv.surface_cds_energy_elements();
        auto nuc = proc_solv.surface_nuclear_energy_elements();
        auto elec = proc_solv.surface_electronic_energy_elements(SpinorbitalKind::Restricted, scf.D);
        auto pol = proc_solv.surface_polarization_energy_elements();
        props.e_coulomb = nuc + elec + pol;
        fmt::print("e_nuc {:12.6f}\n", nuc.array().sum());
        fmt::print("e_ele {:12.6f}\n", elec.array().sum());
        fmt::print("e_pol {:12.6f}\n", pol.array().sum());
        fmt::print("e_cds {:12.6f}\n", props.e_cds.array().sum());
        double esolv = nuc.array().sum() + 
                elec.array().sum() + 
                pol.array().sum() + 
                props.e_cds.array().sum();

        fmt::print("Solvation energy = {:12.6f} ({:.3f} kJ/mol)\n", esolv, esolv * occ::units::AU_TO_KJ_PER_MOL);
        result.push_back(props);
    }

    return result;

}


void compute_monomer_energies(std::vector<Wavefunction> &wfns)
{
    size_t complete = 0;
    for(auto& wfn : wfns)
    {
        fmt::print("Calculating monomer energies {}/{}\n", complete, wfns.size());
        std::cout << std::flush;
        HartreeFock hf(wfn.atoms, wfn.basis);
        occ::interaction::compute_ce_model_energies(wfn, hf);
        complete++;
    }
    fmt::print("Finished calculating {} unique monomer energies\n", complete);
}

auto calculate_transform(const Wavefunction &wfn, const Molecule &m, const Crystal &c)
{
    int sint = m.asymmetric_unit_symop()(0);
    SymmetryOperation symop(sint);
    occ::Mat3N positions = wfn.positions() * BOHR_TO_ANGSTROM;

    occ::Mat3 rotation = c.unit_cell().direct() * symop.rotation() * c.unit_cell().inverse();
    occ::Vec3 translation = (m.centroid() - (rotation * positions).rowwise().mean()) / BOHR_TO_ANGSTROM;
    return std::make_pair(rotation, translation);
}

void write_xyz_dimer(const std::string &filename, const Dimer &dimer)
{
    auto output = fmt::output_file(filename);
    const auto& pos = dimer.positions();
    const auto& nums = dimer.atomic_numbers();
    output.print("{}\n\n", nums.rows());
    for(size_t i = 0; i < nums.rows(); i++)
    {
        output.print("{} {} {} {}\n", Element(nums(i)).symbol(), pos(0, i), pos(1, i), pos(2, i));
    }
}

auto calculate_interaction_energy(const Dimer &dimer, const std::vector<Wavefunction> &wfns, const Crystal &crystal)
{
    const std::string model_name = "ce-b3lyp";
    Molecule mol_A = dimer.a();
    Molecule mol_B = dimer.b();
    const auto& wfna = wfns[mol_A.asymmetric_molecule_idx()];
    const auto& wfnb = wfns[mol_B.asymmetric_molecule_idx()];
    Wavefunction A = wfns[mol_A.asymmetric_molecule_idx()];
    Wavefunction B = wfns[mol_B.asymmetric_molecule_idx()];
    auto transform_a = calculate_transform(wfna, mol_A, crystal);
    A.apply_transformation(transform_a.first, transform_a.second);

    occ::Mat3N pos_A = mol_A.positions();
    occ::Mat3N pos_A_t = A.positions() * BOHR_TO_ANGSTROM;

    assert(all_close(pos_A, pos_A_t, 1e-5, 1e-5));

    auto transform_b = calculate_transform(wfnb, mol_B, crystal);
    B.apply_transformation(transform_b.first, transform_b.second);

    const auto &pos_B = mol_B.positions();
    const auto pos_B_t = B.positions() * BOHR_TO_ANGSTROM;
    assert(all_close(pos_A, pos_A_t, 1e-5, 1e-5));

    auto model = occ::interaction::ce_model_from_string(model_name);

    CEModelInteraction interaction(model);

    auto interaction_energy = interaction(A, B);
    return interaction_energy;
}

std::pair<occ::IVec, occ::Mat3N> environment(const std::vector<Dimer> &neighbors)
{
    size_t num_atoms = 0;
    for(const auto &n: neighbors)
    {
        num_atoms += n.b().size();
    }

    occ::IVec  mol_idx(num_atoms);
    occ::Mat3N positions(3, num_atoms);
    size_t current_idx = 0;
    size_t i = 0;
    for(const auto &n: neighbors)
    {
        size_t N = n.b().size();
        mol_idx.block(current_idx, 0, N, 1).array() = i;
        positions.block(0, current_idx, 3, N) = n.b().positions();
        current_idx += N;
        i++;
    }
    return {mol_idx, positions};
}


std::vector<std::pair<double, double>> compute_solvation_energy_breakdown(
        const SolvatedSurfaceProperties &surface,
        const std::vector<Dimer> &neighbors,
        const std::string& solvent)
{
    std::vector<std::pair<double, double>> energy_contribution(neighbors.size());

    for(int i = 0; i < neighbors.size(); i++) energy_contribution[i] = {0.0, 0.0};

    occ::Mat3N neigh_pos;
    occ::IVec mol_idx;
    occ::IVec neighbor_idx_coul(surface.coulomb_pos.cols());
    occ::IVec neighbor_idx_cds(surface.cds_pos.cols());
    std::tie(mol_idx, neigh_pos) = environment(neighbors);
    
    // coulomb breakdown
    for(size_t i = 0; i < neighbor_idx_coul.rows(); i++)
    {
        occ::Vec3 x = surface.coulomb_pos.col(i);
        Eigen::Index idx = 0;
        double r = (neigh_pos.colwise() - x).colwise().squaredNorm().minCoeff(&idx);
        energy_contribution[mol_idx(idx)].first += surface.e_coulomb(i);
        neighbor_idx_coul(i) = mol_idx(idx);
    }

    // cds breakdown
    for(size_t i = 0; i < neighbor_idx_cds.rows(); i++)
    {
        occ::Vec3 x = surface.cds_pos.col(i);
        Eigen::Index idx = 0;
        double r = (neigh_pos.colwise() - x).colwise().squaredNorm().minCoeff(&idx);
        energy_contribution[mol_idx(idx)].second += surface.e_cds(i);
        neighbor_idx_cds(i) = mol_idx(idx);
    }
    return energy_contribution;
}



int main(int argc, const char **argv) {
    argparse::ArgumentParser parser("interactions");
    parser.add_argument("input").help("Input CIF");
    parser.add_argument("-j", "--threads")
            .help("Number of threads")
            .default_value(2)
            .action([](const std::string& value) { return std::stoi(value); });
    parser.add_argument("--vis")
        .default_value(false)
        .implicit_value(true);
    parser.add_argument("--solvent")
        .help("Solvent name")
        .default_value(std::string("water"))
        .action([](const std::string& value) { return value; });
    parser.add_argument("--radius")
        .help("Radius (angstroms) for neighbours")
        .default_value(3.8)
        .action([](const std::string& value) { return std::stod(value); });
    occ::log::set_level(occ::log::level::info);
    spdlog::set_level(spdlog::level::info);
    libint2::Shell::do_enforce_unit_normalization(false);
    libint2::initialize();
    double radius = 0.0;
    bool dump_visualization_files = false;
    std::string solvent{"water"};

    try {
        parser.parse_args(argc, argv);
        radius = parser.get<double>("--radius");
        dump_visualization_files = parser.get<bool>("--vis");
        solvent = parser.get("--solvent");
    }
    catch (const std::runtime_error& err) {
        occ::log::error("error when parsing command line arguments: {}", err.what());
        fmt::print("{}", parser);
        exit(1);
    }


    using occ::parallel::nthreads;
    nthreads = parser.get<int>("--threads");
    fmt::print("Parallelized over {} threads & {} Eigen threads\n", nthreads, Eigen::nbThreads());


    const std::string error_format = "Exception:\n    {}\nTerminating program.\n";
    try {
        std::string filename = parser.get<std::string>("input");
        std::string basename = fs::path(filename).stem();
        Crystal c = read_crystal(filename);
        fmt::print("Loaded crystal from {}\n", filename);
        auto molecules = c.symmetry_unique_molecules();
        fmt::print("Symmetry unique molecules in {}: {}\n", filename, molecules.size());
        auto wfns = calculate_wavefunctions(basename, molecules);
        auto surfaces = calculate_solvated_surfaces(basename, wfns, solvent);
        compute_monomer_energies(wfns);
        auto crystal_dimers = c.symmetry_unique_dimers(radius);
        const auto &dimers = crystal_dimers.unique_dimers;

        if(dimers.size() < 1)
        {
            fmt::print("No dimers found using neighbour radius {:.3f}\n", radius);
            exit(0);
        }

        const std::string row_fmt_string = "{:>7.2f} {:>7.2f} {:>20s} {: 7.2f} {: 7.2f} {: 7.2f} {: 7.2f} {: 7.2f} {: 7.2f} {: 7.2f} {: 7.2f}\n";

        std::vector<CEModelInteraction::EnergyComponents> dimer_energies;

        fmt::print("Calculating unique pair interactions\n");
        for(const auto& dimer: dimers)
        {
            auto s_ab = dimer_symop(dimer, c);
            write_xyz_dimer(fmt::format("{}_dimer_{}.xyz", basename, dimer_energies.size()), dimer);
            fmt::print("Rc: {:.3f} Rn: {:.3f} symop: {}\n", 
                       dimer.nearest_distance(),
                       dimer.center_of_mass_distance(),
                       s_ab); 

            std::cout << std::flush;
            dimer_energies.push_back(calculate_interaction_energy(dimer, wfns, c));
        }
        fmt::print("Finished calculating {} unique dimer interaction energies\n", dimer_energies.size());

        const auto &mol_neighbors = crystal_dimers.molecule_neighbors;
        for(size_t i = 0; i < mol_neighbors.size(); i++)
        {
            const auto& n = mol_neighbors[i];
            std::optional<std::string> solv_filename{};
            if(dump_visualization_files)
            {
                solv_filename = fmt::format("{}_{}_solvation_vis.xyz", basename, i);
            }
            auto solv = compute_solvation_energy_breakdown(surfaces[i], n, solvent);

            fmt::print("Neighbors for molecule {}\n", i);

            fmt::print("{:>7s} {:>7s} {:>20s} {:>7s} {:>7s} {:>7s} {:>7s} {:>7s} {:>7s} {:>7s} {:>7s}\n",
                       "Rn", "Rc", "Symop", "E_coul", "E_rep", "E_pol", "E_disp", "E_tot", "E_scoul", "E_scds", "E_int");
            fmt::print("============================================================================================\n");

            size_t j = 0;
            CEModelInteraction::EnergyComponents total; 

            for(const auto& dimer: n)
            {
                auto s_ab = dimer_symop(dimer, c);
                size_t idx = crystal_dimers.unique_dimer_idx[i][j]; 
                double rn = dimer.nearest_distance();
                double rc = dimer.center_of_mass_distance();
                const auto& e = dimer_energies[crystal_dimers.unique_dimer_idx[i][j]];
                double ecoul = e.coulomb_kjmol(), erep = e.exchange_kjmol(),
                    epol = e.polarization_kjmol(), edisp = e.dispersion_kjmol(),
                    etot = e.total_kjmol();
                total.coulomb += ecoul;
                total.exchange_repulsion += erep;
                total.polarization += epol;
                total.dispersion += edisp;
                total.total += etot;

                fmt::print(row_fmt_string, rn, rc, s_ab, ecoul, erep, epol, edisp, etot, solv[j].first * AU_TO_KJ_PER_MOL,
                           solv[j].second * AU_TO_KJ_PER_MOL, etot - (solv[j].first + solv[j].second) * AU_TO_KJ_PER_MOL);
                j++;
            }
            fmt::print("Total: {:.3f} kJ/mol\n", total.total);
        }

     } catch (const char *ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::string &ex) {
        fmt::print(error_format, ex);
        return 1;
    } catch (std::exception &ex) {
        fmt::print(error_format, ex.what());
        return 1;
    } catch (...) {
        fmt::print("Exception:\n- Unknown...\n");
        return 1;
    }
   
    return 0;
}
